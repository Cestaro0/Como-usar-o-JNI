# How-to-use-JNI
Como usar e consumir um codigo jni
Como usar JNI, java e c++ juntos.


 Primeiramente, para você conseguir usar JNI, tenha uma plataforma de desenvolvimento, como o intellij. Baixe o java e o configure para conseguir usa-lo em terminal.
 Agora, baixe o visual studio, ele vai ser necessario para a criação do nosso wrapper.


- Como funciona o JNI:
Para entendermos um pouco melhor o que vamos fazer aqui e o porque que de utilizar isso, será necessario uma breve explicação. 
Imagine a seguinte situação: Você é um programador e tem uma aplicação java mas precisa rodar um código que está em uma .dll
C/C++, como vc faz isso? Usando o JNI (Java Native Interface). Funciona assim:


Aplicação Java |  Wrapper  | Dll
     JAVA --->  JAVA + C/C++ ---> C/C++

Então vc vai ter os seguintes arquivos: um arquivo .java, e dois .dll (ou so). O java vai fazer a comunicação com a .dll c/c++ 
por meio de um wrapper que é a mistura dos dois. Sem mais delongas, vamos colocar a mao na massa.


- JAVA 
 Crie um projeto, e faça o seguinte codigo:

```java
public class CallCppDll {
     public static native int sum(int a, int b);
     public static native String hello();

     public static void main(String[] args) {
        
    }      
}
```
- C/C++

Crie uma biblioteca de vinculo dinamico


abra um terminal na pasta do projeto e digite o seguinte codigo:

```bash
javac CallCppDll.java -h "Caminho da pasta do projeto cpp que vc criou"
```


isso vai criar um .h na sua pasta do projeto do c++, ela que vc irá utilizar para fazer o wrapper.

Vamos para o C++ agora:

Adicione o Arquivo "CallCppDll.h" e crie um "CallCppDll.cc"

inclua o iostream e windows seu .h deve estar assim:

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <iostream>
#include <windows.h>
/* Header for class CallCppDll */

#ifndef _Included_CallCppDll
#define _Included_CallCppDll
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     CallCppDll
 * Method:    sum
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_CallCppDll_sum
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     CallCppDll
 * Method:    hello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_CallCppDll_hello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

agora copie as assinaturas e vamos para o cpp, inclua seu cabeçalho e seu codigo deve estar assim:
```cpp
#include "CallCppDll.h"

extern "C"
{
	JNIEXPORT jint JNICALL Java_CallCppDll_sum(JNIEnv* env, jclass cls, jint a, jint b)
	{
		HMODULE hMod = LoadLibraryA("D:\\DEV\\JNI\\DllSUM.dll");
		typedef int (*sum)(int, int);
		sum s = reinterpret_cast<sum>(GetProcAddress(hMod, "sum"));

		return s(a, b);
	}

	
	JNIEXPORT jstring JNICALL Java_CallCppDll_hello(JNIEnv* env, jclass cls)
	{
		HMODULE hMod = LoadLibraryA("D:\\DEV\\JNI\\DllHELLO.dll");
		typedef const char* (*hello)();
		hello h = reinterpret_cast<hello>(GetProcAddress(hMod, "hello"));

		return env->NewStringUTF(h());
	}
}
```

agora no projeto vá em Propriedades -> C/C++ -> Diretorios de inclusão adicionais. E inclua os seguintes caminhos "C:\Program Files\Java\jdk1.8.0_333\include" "C:\Program Files\Java\jdk1.8.0_333\include\win32" clique em aplicar e pronto, apenas compile sua aplicação na arquitetura que for seu computador (não se esqueça de remo
ver o cabeçalho pre compilado, se nao ocorrerá um erro).Lembrando x32 roda apenas x32, e x64 apenas x64.


Agora no java novamente, vamos fazer a chamada da DLL compilada e apenas a usar, seu codigo deve estar assim:
```java
public class CallCppDll {

    static
    {
        System.load("D:\\DEV\\JNI\\Dll1\\x64\\Release\\Dll1.dll");
    }

    public static native int sum(int a, int b);
    public static native String hello();

    public static void main(String[] args) {
        System.out.println(sum(1,2));
        System.out.println(hello());
    }

}
```

agora apenas rode, o output deve ser esse:
```
3
Hello from c++
```
